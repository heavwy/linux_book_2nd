# linux学习笔记

## writel_relaxed

**背景介绍**

`writel_relaxed`通常是在设备驱动或者底层硬件访问相关的代码中出现的函数。它主要用于向特定的硬件寄存器或者内存映射的I/O（MMIO）区域进行写入操作。这种写入操作可能是对硬件设备进行配置、发送命令或者传递数据等。   - 在一些内核代码（如Linux内核）或者嵌入式系统开发中较为常见。例如，在ARM架构的设备驱动开发中，当需要对一些特殊功能寄存器（SFR）进行操作时会用到类似的函数。

**功能细节解释**

“write”表示写入操作，“l”可能代表“long”（长整型）数据类型的写入。在一些系统中，硬件寄存器可能是32位（长整型）的宽度，所以`writel`函数用于将一个32位的值写入到指定的地址。   

- `relaxed`后缀表示一种较为“宽松”的写入方式。这通常是和内存访问顺序有关的概念。在严格的内存访问模型中，处理器需要保证内存操作按照程序指定的顺序执行。而`relaxed`操作允许在一定程度上不严格按照程序顺序执行内存操作，这在一些硬件体系结构中可以提高性能，因为它减少了处理器等待内存操作完成的时间。   

- 例如，在某些多核处理器或者具有缓存层次结构的系统中，为了充分利用硬件的并行性和缓存特性，`writel_relaxed`可以在不影响程序正确性的前提下（对于一些对写入顺序不敏感的寄存器），更快地完成写入操作。

**示例代码（以Linux内核风格为例）**

假设我们有一个简单的设备驱动，需要向一个设备的控制寄存器写入一个配置值。   - 首先，定义设备寄存器的地址：

```\
#define DEVICE_CONTROL_REGISTER_ADDRESS 0x12345678
```

然后，使用`writel_relaxed`写入一个值（假设这个值是0xABCD）:

```
#include <asm/io.h>
void configure_device(void)
{
    writel_relaxed(0xABCD, (void __iomem *)DEVICE_CONTROL_REGISTER_ADDRESS);
}
```

在这个示例中，`writel_relaxed`函数将0xABCD这个32位的值写入到了`DEVICE_CONTROL_REGISTER_ADDRESS`所指向的设备控制寄存器。`void __iomem *`是一种用于表示内存映射I/O区域的指针类型，告诉编译器这个地址是用于I/O操作的，而不是普通的内存地址。 

**注意事项** 

使用`writel_relaxed`需要谨慎，因为它的“宽松”特性可能会导致在某些对写入顺序敏感的情况下出现问题。例如，如果多个寄存器之间存在依赖关系，错误地使用`relaxed`写入可能会导致硬件无法正确地接收到配置信息。   - 在不同的硬件平台和编译器环境下，`writel_relaxed`的实现可能会有所不同。有些平台可能不支持这种“宽松”的写入方式，或者可能需要特殊的配置才能使用。所以在移植代码或者开发跨平台的驱动时，需要仔细检查和测试。



## __iomem

1. **含义**   
   - 在Linux内核（特别是设备驱动开发相关部分）中，`__iomem`是一个类型修饰符。它用于标记一个指针，这个指针指向的是I/O内存（Input/Output Memory）区域。I/O内存是一种特殊的内存区域，用于和外部设备进行数据交互，比如设备的寄存器空间等。 
2. **用途**   
   - **访问控制和正确性检查**：     
     - 当一个指针被标记为`__iomem`后，编译器和内核的一些工具可以更好地对其进行访问控制。这有助于防止一些不恰当的内存访问操作，例如，普通的内存读写操作和I/O内存读写操作在很多情况下是有区别的。通过这种标记，内核可以在编译时或者运行时（通过一些额外的检查机制）对访问这些特殊内存区域的代码进行更严格的审查。     
     - 例如，在设备驱动程序中，对于一些硬件寄存器的访问，使用`__iomem`标记的指针可以确保这些访问符合硬件设备的要求。假设一个设备有一个控制寄存器，通过`__iomem`标记的指针指向这个寄存器的内存地址，当驱动程序对这个指针进行读写操作时，编译器可以根据这个标记知道这是对I/O内存的访问，从而可以应用一些特殊的规则，如字节序调整（因为硬件寄存器的字节序可能和CPU的字节序不同）或者访问权限检查（确保只有授权的操作才能访问寄存器）。   
   - **可移植性和抽象性**：     
     - 不同的硬件平台对于I/O内存的访问方式可能有所不同。`__iomem`标记提供了一种抽象机制，使得设备驱动开发者可以以一种相对统一的方式编写访问I/O内存的代码。内核在底层会根据硬件平台的具体情况（例如，是ARM架构还是x86架构）来实现正确的I/O内存访问机制，而`__iomem`标记可以帮助内核识别这些需要特殊处理的内存访问。     
     - 以ARM和x86为例，ARM可能通过特定的协处理器指令来访问I/O内存，而x86可能使用I/O端口映射等不同的方式。在Linux内核中，当一个驱动程序使用`__iomem`标记的指针来访问I/O内存时，内核会根据当前的硬件架构来调用合适的底层函数来实现实际的访问，这样就提高了驱动程序的可移植性。



## scanf("%\[^\n\]%*c", sendstring)

1. `scanf` 函数概述 

   `scanf` 是 C 语言中用于从标准输入（通常是键盘）读取数据，并按照指定的格式将数据存储到相应变量中的函数。它的一般形式为 `scanf("格式控制字符串", 地址列表);`，其中格式控制字符串规定了输入数据的格式以及如何进行转换，地址列表则是接收输入数据的变量的地址。 

2. `%[^\n]` 格式说明符 

   这是一种 `scanf` 中的扫描集（scanset）格式说明符。`%[` 表示开始定义扫描集，`^\n` 表示匹配除了换行符 `\n` 之外的任意字符序列。也就是说，它会持续读取输入的字符，直到遇到换行符为止，并把读取到的这些字符存储到对应的字符数组（在这里是 `sendstring`）中。

   **示例**： 例如，如果用户输入 `Hello, world!` 然后按下回车键，那么 `sendstring` 数组就会存储 `Hello, world!` 这个字符串（包含空格等字符，只要不是换行符都会被读取进来）。 

3. `%*c` 部分 

    `%*` 是一种用于抑制赋值的格式修饰符。在这里 `%*c` 表示读取一个字符（也就是换行符 `\n`，因为前面 `%[^\n]` 读到换行符就停止了，此时换行符还留在输入缓冲区中），但不将这个字符赋值给任何变量，直接丢弃它。这么做的目的通常是为了清除输入缓冲区中遗留的换行符，避免其对后续输入操作产生影响（比如后续还有其他 `scanf` 语句进行不同类型数据的读取时，防止误把这个换行符当作有效输入）。 

4. 使用注意事项

   **字符数组大小**： 在使用 `%[^\n]` 读取输入到字符数组时，要确保字符数组有足够的空间来存放读取到的字符串，包括字符串结束标志 `'\0'`，否则可能会导致缓冲区溢出等错误。例如，如果定义 `char sendstring[10];` 而用户输入了很长的一串字符（超过9个有效字符，因为还要留一个位置给 `'\0'`），就会出现问题。 

   **输入合法性**： 这种读取方式可能使得输入的内容比较随意，不像使用 `%s` 那样会以空白字符（空格、制表符、换行符等）作为字符串结束标志那样规范，所以如果后续程序对输入的字符串有格式等方面的要求，需要额外进行合法性验证等操作。 总的来说，`scanf("%[^\n]%*c", sendstring);` 语句常被用于读取一行文本输入（直到遇到换行符为止），并且顺手清除输入缓冲区中的换行符的场景。 

## mamp

在使用 `mmap` 进行匿名映射时，通常是需要页对齐的 。

### 原因

- **操作系统的内存管理要求**：现代操作系统的内存管理是以页为基本单位的。当进行 `mmap` 匿名映射时，如果地址不是页对齐的，操作系统在处理内存映射时可能会面临一些复杂的情况，这可能导致额外的开销和潜在的性能问题。
- **硬件的内存访问特性**：许多现代硬件在访问内存时，对于页对齐的地址有更高效的访问方式。如果地址不是页对齐的，可能会导致硬件在进行内存访问时需要进行额外的操作，如地址转换和数据对齐等，从而降低了内存访问的效率。

### 对齐要求的具体体现

- **映射地址的要求**：一般来说，`mmap` 函数的参数中指定的映射起始地址应该是系统页面大小的整数倍。在大多数 Linux 系统中，页面大小通常是 4KB（4096 字节），所以映射的起始地址应该是 4096 的倍数。
- **映射长度的要求**：虽然 `mmap` 对于映射长度并没有强制要求必须是页对齐的，但从性能和内存管理的角度考虑，通常也建议将映射长度设置为页的整数倍。这样可以确保整个映射区域在内存中是完整的页，便于操作系统进行有效的内存管理和硬件进行高效的内存访问。
